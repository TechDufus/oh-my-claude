#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = []
# ///
"""
PreToolUse hook that enforces commit message quality and conventional commit format.

Intercepts `git commit` commands and validates:
1. Conventional commit format: <type>[scope]: <description>
2. Subject line max 50 characters
3. Body lines max 72 characters
4. No AI attribution (generated by claude, co-authored-by ai, etc.)
5. Message body appropriate for diff size
"""
from __future__ import annotations

import json
import re
import subprocess
import sys
from pathlib import Path

# Add parent directory for hook_utils import
sys.path.insert(0, str(Path(__file__).parent))

from hook_utils import (
    hook_main,
    log_debug,
    output_empty,
    parse_hook_input,
    read_stdin_safe,
)

# Conventional commit format regex
# Format: <type>[optional scope][!]: <description>
CONVENTIONAL_COMMIT_REGEX = re.compile(r'^[a-z]+(\([a-z0-9\-]+\))?!?: .+$')

# Forbidden AI attribution patterns (case-insensitive)
# Only match clear attribution language, not feature names
FORBIDDEN_PATTERNS = [
    # "Generated/Created/Written by/with" attribution phrases
    re.compile(r'generated (with|by) (claude|ai|gpt|chatgpt|anthropic)', re.IGNORECASE),
    re.compile(r'created by (claude|ai|gpt|chatgpt|anthropic)', re.IGNORECASE),
    re.compile(r'written by (claude|ai|gpt|chatgpt|anthropic)', re.IGNORECASE),
    # Co-author attributions (git trailer format)
    re.compile(r'co-authored-by:?\s*(claude|ai|anthropic|chatgpt|copilot)', re.IGNORECASE),
    # Explicit AI-generated markers
    re.compile(r'\bai-generated\b', re.IGNORECASE),
    re.compile(r'\bai-assisted\b', re.IGNORECASE),
    # Robot emoji (unlikely in legitimate commits)
    re.compile(r'\U0001F916'),
]


def output_deny(reason: str) -> None:
    """Output denial response for PreToolUse hook."""
    response = {"decision": "deny", "reason": reason}
    print(json.dumps(response))
    sys.exit(0)


def get_staged_diff_stats() -> tuple[int, int]:
    """
    Get statistics about staged changes.

    Returns:
        Tuple of (lines_changed, files_changed)
    """
    try:
        # Get number of lines changed
        result = subprocess.run(
            ["git", "diff", "--cached", "--numstat"],
            capture_output=True,
            text=True,
            timeout=5,
        )

        if result.returncode != 0:
            return 0, 0

        lines_added = 0
        lines_deleted = 0
        files_changed = 0

        for line in result.stdout.strip().split("\n"):
            if not line:
                continue
            parts = line.split("\t")
            if len(parts) >= 2:
                files_changed += 1
                # Handle binary files (shown as -)
                if parts[0] != "-":
                    lines_added += int(parts[0])
                if parts[1] != "-":
                    lines_deleted += int(parts[1])

        return lines_added + lines_deleted, files_changed

    except (subprocess.TimeoutExpired, subprocess.SubprocessError, ValueError):
        return 0, 0


def extract_commit_message(command: str) -> str | None:
    """
    Extract commit message from a git commit command.

    Handles:
    - git commit -m "message"
    - git commit -m 'message'
    - git commit -m "$(cat <<'EOF'\nmessage\nEOF\n)"
    """
    # Pattern for -m "message" or -m 'message'
    simple_pattern = r'-m\s+["\'](.+?)["\']'
    match = re.search(simple_pattern, command, re.DOTALL)
    if match:
        return match.group(1)

    # Pattern for HEREDOC: -m "$(cat <<'EOF' ... EOF )"
    heredoc_pattern = r'-m\s+"\$\(cat\s+<<[\'"]?EOF[\'"]?\s*\n(.+?)\nEOF\s*\)"'
    match = re.search(heredoc_pattern, command, re.DOTALL)
    if match:
        return match.group(1)

    # Alternative HEREDOC without quotes
    heredoc_pattern2 = r"-m\s+'\$\(cat\s+<<['\"]?EOF['\"]?\s*\n(.+?)\nEOF\s*\)'"
    match = re.search(heredoc_pattern2, command, re.DOTALL)
    if match:
        return match.group(1)

    return None


def validate_message_format(message: str) -> tuple[bool, list[str]]:
    """
    Validate commit message format against conventional commit standards.

    Checks:
    1. Subject line max 50 characters
    2. Body lines max 72 characters
    3. Conventional commit format
    4. No AI attribution

    Returns:
        Tuple of (is_valid, list_of_errors)
    """
    errors = []
    first_content_line = None
    line_num = 0

    for line in message.split('\n'):
        line_num += 1

        # Skip comment lines (starting with #)
        if line.strip().startswith('#'):
            continue

        # Skip empty lines until first content line
        if first_content_line is None and not line.strip():
            continue

        # First non-comment, non-empty line is the subject
        if first_content_line is None:
            first_content_line = line

            # Check subject line length (50 chars max)
            if len(line) > 50:
                errors.append(
                    f"Subject line exceeds 50 characters ({len(line)} chars): "
                    f"'{line[:50]}...'"
                )
        else:
            # Body lines: max 72 characters
            if len(line) > 72:
                errors.append(
                    f"Line {line_num} exceeds 72 characters ({len(line)} chars)"
                )

    # Check conventional commit format
    if first_content_line:
        if not CONVENTIONAL_COMMIT_REGEX.match(first_content_line):
            errors.append(
                "Subject must use conventional commit format: "
                "<type>[scope]: <description>\n"
                "Examples: feat: add feature, fix(auth): resolve bug"
            )

    # Check for forbidden AI attribution
    for pattern in FORBIDDEN_PATTERNS:
        if pattern.search(message):
            errors.append(
                "Commit message contains forbidden AI attribution. "
                "Commits should reflect human ownership, not tool attribution."
            )
            break

    return (len(errors) == 0, errors)


def count_message_body_lines(message: str) -> int:
    """Count non-empty lines in the commit message body (after subject)."""
    lines = message.strip().split("\n")

    if len(lines) <= 1:
        return 0

    # Skip subject line and blank line after it
    body_lines = []
    in_body = False

    for i, line in enumerate(lines[1:], start=1):
        if not in_body:
            if line.strip() == "":
                in_body = True
            continue
        if line.strip():
            body_lines.append(line)

    return len(body_lines)


def evaluate_message_quality(
    message: str,
    lines_changed: int,
    files_changed: int
) -> tuple[bool, str]:
    """
    Evaluate if commit message quality matches the change size.

    Returns:
        Tuple of (is_acceptable, reason_if_not)
    """
    body_lines = count_message_body_lines(message)
    subject = message.strip().split("\n")[0] if message else ""

    log_debug(
        f"Evaluating: {lines_changed} lines, {files_changed} files, "
        f"{body_lines} body lines, subject: '{subject[:50]}...'"
    )

    # Trivial changes (< 10 lines, 1-2 files): subject-only is fine
    if lines_changed < 10 and files_changed <= 2:
        return True, ""

    # Small changes (10-50 lines): need at least some context
    if lines_changed < 50:
        if body_lines == 0:
            return False, (
                f"This commit changes {lines_changed} lines across {files_changed} file(s). "
                f"Add a commit body explaining WHY these changes were made. "
                f"Example:\n\n"
                f"{subject}\n\n"
                f"Brief explanation of the problem and solution approach."
            )
        return True, ""

    # Medium changes (50-200 lines): need proper body
    if lines_changed < 200:
        if body_lines < 2:
            return False, (
                f"This commit changes {lines_changed} lines across {files_changed} file(s). "
                f"The commit body should have at least 2-3 lines explaining:\n"
                f"- What problem this solves\n"
                f"- How you approached it\n"
                f"- Any notable decisions or tradeoffs"
            )
        return True, ""

    # Large changes (200+ lines): need detailed explanation
    if body_lines < 4:
        return False, (
            f"This commit changes {lines_changed} lines across {files_changed} file(s). "
            f"Large changes require detailed commit messages. Include:\n"
            f"- Context: What problem does this solve?\n"
            f"- Approach: How did you solve it?\n"
            f"- Changes: List the key modifications (use bullet points)\n"
            f"- Impact: What does this enable or fix?\n\n"
            f"Use bullet points to organize multiple changes."
        )

    return True, ""


@hook_main("PreToolUse")
def main() -> None:
    """Main hook entry point."""
    raw = read_stdin_safe()
    data = parse_hook_input(raw)

    tool_name = data.get("tool_name", "")

    # Only intercept Bash commands
    if tool_name != "Bash":
        output_empty()
        return

    tool_input = data.get("tool_input", {})
    command = tool_input.get("command", "")

    # Only intercept git commit commands
    if not re.search(r"\bgit\s+commit\b", command):
        output_empty()
        return

    log_debug(f"Intercepted git commit: {command[:100]}...")

    # Skip if this is --amend without a new message (editing existing)
    if "--amend" in command and "-m" not in command:
        log_debug("Skipping --amend without -m (interactive edit)")
        output_empty()
        return

    # Extract the commit message
    message = extract_commit_message(command)

    if not message:
        log_debug("Could not extract commit message, allowing through")
        output_empty()
        return

    # First, validate message format (conventional commits, lengths, AI attribution)
    format_valid, format_errors = validate_message_format(message)

    if not format_valid:
        log_debug(f"Denying commit - format errors: {format_errors}")
        error_list = "\n".join(f"â€¢ {e}" for e in format_errors)
        output_deny(
            f"[Commit Format Validation Failed]\n\n{error_list}\n\n"
            f"Fix the format errors and try again."
        )
        return

    # Get diff statistics for quality evaluation
    lines_changed, files_changed = get_staged_diff_stats()

    if lines_changed == 0 and files_changed == 0:
        log_debug("No staged changes detected, allowing through")
        output_empty()
        return

    # Evaluate message quality (body detail appropriate for diff size)
    is_acceptable, reason = evaluate_message_quality(
        message, lines_changed, files_changed
    )

    if not is_acceptable:
        log_debug(f"Denying commit: {reason[:100]}...")
        output_deny(
            f"[Commit Quality Check Failed]\n\n{reason}\n\n"
            f"Rewrite the commit message with more detail and try again."
        )
        return

    log_debug("Commit message passes all checks")
    output_empty()


if __name__ == "__main__":
    main()
